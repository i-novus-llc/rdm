# СИНХРОНИЗАЦИЯ СПРАВОЧНИКОВ

Общая информация
Синхронизация справочников предназначена для переноса данных справочников НСИ в бд клиента синхронизации. Клиент синхронизации в своей бд создает таблицы соответствующей структуры, в которые будет происходить копирование данных НСИ. Синхронизатор предоставляет api для запуска копирования. В какой момент запускать процесс синхронизации клиент реализует сам.

## Первый запуск
1. Добавить в pom зависимость.
    ```
    <dependency>
        <groupId>ru.inovus.ms.rdm</groupId>
        <artifactId>rdm-sync-spring-boot-starter</artifactId>
        <version>${rdm.version}</version>
    </dependency>
    ```

2. Запустить клиентское приложение
Нужно, чтобы отработал liquibase.
В базе данных должна создаться схема rdm_sync с таблицами:

version - список справочников которые необходимо синхронизировать с НСИ;
field_mapping - маппинг полей;
log - журнал обновления.

**Важно:** liquibase rdm sync запускается ПОСЛЕ общего liquibase, сконфигурированного по умолчанию. Поэтому, если нужно добавить в общем liquibase что-то,
что производит изменения в схеме rdm_sync, то нужно это добавлять в директорию /rdm-sync-db/changelog.

3. Необязательно.
Чтобы методы сервиса отображались в swagger клиента, в application.properties добавить к настройкe swagger пакет синхронизатора через запятую: jaxrs.swagger.resource-package=..., ru.inovus.ms.rdm.service

4. Обновление всех справочников, которые ведутся в системе клиента:
{CLIENT_SERVICE_URL}/rdm/update
Обновление конкретного справочника:
{CLIENT_SERVICE_URL}/rdm/update?refbookCode=A001


## Настройка маппинга
Маппинг - это соответствие полей справочника в системе НСИ и колонок таблицы в бд клиента. Описание маппинга производится в таблице rdm_sync.field_mapping(см комментарии к колонкам). Описание какой справочник копировать в какую таблицу производится в таблице rdm_sync.version.
Маппинг можно настроить напрямую в бд и через xml конфигурацию.
### Через бд
Добавляем запись на каждый справочник в rdm_sync.version. Заполняем колонки code - код справочника в НСИ, sys_table - название таблицы в бд клиента, unique_sys_field - заполняем значением “code”, deleted_field - заполняем значением “is_deleted ”.
Пример :
Добавляем запись на каждое поле справочника(которое нужно скопировать в бд клиента) в rdm_sync.field_mapping. Поле справочника, которое является первичным ключом справочника в НСИ, должно маппиться в колонку code
Пример :
```
insert into rdm_sync.version(code, sys_table, unique_sys_field, deleted_field)
select 'S019', 'rdm.grade_test', 'code', 'is_deleted';

insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'code', 'varchar', 'id';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'test_text', 'varchar', 'test_text';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'sequence', 'integer', 'sequence';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'grade_request_id', 'varchar', 'grade_request_id';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'is_required', 'boolean', 'is_required';
```
### Через xml
В classpath (например в папку resources) подкладываем файл с наименование *rdm-mapping.xml*. В случае изменения маппинга меняем в файле соответвующий элемент refbook и увеличиваем mapping-version на 1.
Пример:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<mapping>

    <refbook code="T001" sys-table="rdm.test_rb" unique-sys-field="code" deleted-field="is_deleted" mapping-version="1">
        <field sys-field="code" sys-data-type="varchar" rdm-field="id"/>
        <field sys-field="name" sys-data-type="varchar" rdm-field="short_name"/>
        <field sys-field="doc_number" sys-data-type="integer" rdm-field="doc_num"/>
    </refbook>

    <refbook code="R001" sys-table="rdm.some_table" unique-sys-field="code" deleted-field="is_deleted" mapping-version="1">
        <field sys-field="code" sys-data-type="varchar" rdm-field="id"/>
        <field sys-field="name" sys-data-type="varchar" rdm-field="short_name"/>
    </refbook>

</mapping>
```

## Из ограничений:
- не использовать ссылочные справочники.
- справочники без первичных ключей не смогут синхронизироваться.
- строковый тип в НСИ можно мапить в "varchar", "text", "character varying", "smallint", "integer", "bigint", "serial", "bigserial", boolean(true/false), "numeric", "decimal",  "date(yyyy-MM-dd)"
- дату из НСИ можно  мапить в "date", "varchar", "text", "character varying"
- дробный в НСИ можно маппить в "numeric", "decimal", "varchar", "text", "character varying"
-логический тип в НСИ можно маппить в boolean, "varchar", "text", "character varying"




## Создание таблиц для копирования данных из НСИ

Таблицы создавать в схеме rdm.
Таблица должна содержать технические колонки :
UUID id - внутрений первичный ключ таблицы, на него можно ссылаться внутри системы.
code - любой совместимый тип с типом первичного ключа справочника в нси. В эту колонку будет копироваться значение первичного ключа справочника в нси. указывается в колонке rdm_sync.version.unique_sys_field
is_deleted - признак удалена ли запись или нет. указывается в колонке rdm_sync.version.deleted_field
Таблица должна содержать для значений справочника, т.е те колонки в которые будут копироваться данные из полей справочника. Их кол-во и название не обязательно должны совпадать. Эти колонки участвуют в маппинге, т.е прописываются в rdm_sync.field_mapping



## Возможность импортировать справочник по событию публикации:
- Необходимо задать значение свойств `rdm_sync.publish.listener.enable`, `spring.activemq.broker-url`, `rdm_sync.publish.topic`.  
Первое включает возможность импортировать справочник по событию (по - умолчанию выключено).  
Второе свойство -- это адрес брокера ActiveMQ. Он должен совпадать с адресом брокера, на который уходят сообщения о публикации, т.е с аналогичной настройкой для rdm-rest.  
Третье -- это название топика, по которому вещаются события публикации справочников (по - умолчанию `publish_topic`).  
Можно использовать либо JMS 1.1 (ActiveMQ), либо JMS 2.0 (Artemis), то бишь если вы указали  `rdm_sync.publish.listener.enable` как `true` -- добавляем зависимости либо от ActiveMQ, либо от Artemis (но не обе!).  
В случае с ActiveMQ справочник при событии публикации будет блокироваться (так как спецификация JMS 1.1 не поддерживает механизм SharedSubscription и сообщение о публикации примерно одновременно получат все узлы кластера).  
В случае с Artemis-ом блокировок не будет и можно параллельно с синхронизацией модифицировать таблицу со справочником (желательно ограничиться только добавлением записей, которых там точно никогда быть не могло, чтобы избежать конфликтов).


## Возможность синхронизировать данные в сторону RDM
- Если в вашем приложении есть какая - то сущность, которая отражена в RDM -- вы можете синхронизировать ее.  
Сущности, которые вы синхронизируете с RDM должны реализовывать интерфейс `Serializable`. То же самое применяется для всех полей сущности рекурсивно. Вы можете передать либо экземпляр какой - то конкретной сущности, либо `Map`. В первом случае все поля сущности (вплоть до `Object`-а) будут сложены в `Map` (нерелевантные поля будут отфильтрованы на стороне RDM).  
В RDM в качестве первичного ключа записи используются идентификаторы, которые вам в общем случае неизвестны, поэтому все операции `Update/Delete` выполняются по первичному ключу **справочника**, который должен быть представлен в вашей сущности.
Базовый интерфейс для данной операции отражен в `ru.inovus.ms.rdm.sync.service.change_data.RdmChangeDataClient`.  
У данного интерфейса есть две реализации, синхронная и асинхронная. Синхронная блокирует вызывающего, асинхронная положит сообщение в очередь и сразу вернет управление.  
Чтобы явно указать синхронную реализацию (хотя это делать необязательно, по - умолчанию используется именно синхронная реализация) -- необходимо задать значения свойства `rdm_sync.change_data_mode` как `sync`.  
Соответственно для асинхронной реализации указываем `async`.  
Если вы решили использовать синхронную реализацию -- убедить, что вы сконфигурировали брокера сообщений. Также в classpath-е должна быть реализация JMS спецификации (например, ActiveMQ).  
Результаты и синхронной, и асинхронной операций можно перехватить через `ru.inovus.ms.rdm.sync.service.change_data.RdmChangeDataRequestCallback`. По - умолчанию она просто логгирует в консоль.  
Стоит отметить, что в асинхронной реализации контейнер слушателя установлен как транзакционный. Это значит, что spring-jms не отправит Acknowledge брокеру сообщений в случае, если метод слушателя (помеченный как @JmsListener) кинет исключение.
Поэтому необходимо выставить разумные значения для двух параметров: кол - во попыток и задержка между ними. Однако в спецификации JMS эти параметры не указаны и настраиваются на стороне брокера.  
Например, если у вас Artemis -- то в папке `${artemis-broker}/etc` лежит файл `broker.xml`. В нем есть секция `<address-settings>`. Туда можно добавить `<address-setting>` с `match=jms.queue.${rdm_sync.change_data.queue}` (по - умолчанию `rdm_sync.change_data.queue` равна `rdmChangeData`). Внутри прописываем `<redelivery-delay>DELAY</redelivery-delay>`. В `DELAY` подставляем разумное значение (5 секунд, например) в милисекундах. И туда же прописываем `<max-delivery-attempts>ATTEMPTS</max-delivery-attempts>`.  
Аналогичные настройки можно найти у других брокеров.


## Возможность обновлять данные в локальной таблице
Эту возможность имеет смысл использовать в связке с вышеописанной.  
Локальные таблицы хранят в себе системное поле, указывающее в каком отношении с соответствующей записью в RDM находится локальная запись.  
Это поле может принимать 4 значения.  
1) `SYNCED` -- указывающее, что локальная запись была синхронизирована с RDM и с тех пор не менялась (то есть при условии, что в RDM не публиковали справочник, эта запись -- корректное отражение ее в локальной таблице).  
2) `DIRTY` -- указывающее, что локальная запись была отредактирована (либо руками, либо программно) и она уже не отражает соотвествующую запись в RDM.
3) `PENDING` -- указывающее, что локальная запись была поставлена в очередь на экспорт ее в RDM.
4) `ERROR` -- указывающее, что экспорт в RDM завершился с ошибкой. Это состояние также логически является расширением состояния `DIRTY`.  
Диаграмма переходов состояний, при условии, что запись не модифицируется во время пребывания ее в состоянии `PENDING`, выглядит так:  
`SYNCHED`→`DIRTY`  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↙  
`PENDING`→`ERROR`  