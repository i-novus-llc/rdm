# СИНХРОНИЗАЦИЯ СПРАВОЧНИКОВ

## Общая информация
Синхронизация справочников предназначена для переноса данных справочников НСИ в бд клиента синхронизации. Клиент синхронизации в своей бд создает таблицы соответствующей структуры, в которые будет происходить копирование данных НСИ. Синхронизатор предоставляет api для запуска копирования. В какой момент запускать процесс синхронизации клиент реализует сам, либо включает автоматическое обновление на основе событий публикации справочника.
Также добавлена возможность экспорта данных в НСИ в синхронном/асинхронном режиме и периодически по рассписанию.

## Требования к клиентскому приложению
1. Клиенсткое приложение должно быть реализованно на java 11, spring-boot 2 и на платформе n2o-platform версии 2.18.
2. Должно использовать библиотеку Liquibase для автоматического обновления базы данных
3. Использовать фреймворк для автоматизации сборки проектов maven3

## Подключение
1. Добавить в pom зависимость.
    ```
    <dependency>
        <groupId>ru.inovus.ms.rdm</groupId>
        <artifactId>rdm-sync-spring-boot-starter</artifactId>
        <version>${rdm.version}</version>
    </dependency>
    ```
2. Настроить маппинг.

3. Запустить клиентское приложение
<br>
В базе данных должна создаться схема rdm_sync с таблицами:

version - список справочников которые необходимо синхронизировать с НСИ;
field_mapping - маппинг полей;
log - журнал обновления.

**Важно:** liquibase rdm sync запускается ПОСЛЕ общего liquibase, сконфигурированного по умолчанию. Поэтому, если нужно добавить в общем liquibase что-то,
что производит изменения в схеме rdm_sync, то нужно это добавлять в директорию /rdm-sync-db/changelog.

После запуска у клиентского приложения будет доступно API:
1. POST {CLIENT_SERVICE_URL}/rdm/update обновление всех справочников, которые ведутся в системе клиента

2. POST {CLIENT_SERVICE_URL}/rdm/update?refbookCode=A001 обновление конкретного справочника, где A001 код справочника


## Настройка маппинга
Маппинг - это соответствие полей справочника в системе НСИ и колонок таблицы в бд клиента. Описание маппинга производится в таблице rdm_sync.field_mapping(см комментарии к колонкам). Описание какой справочник копировать в какую таблицу производится в таблице rdm_sync.version.
Маппинг можно настроить напрямую в бд и через xml конфигурацию.
### Через бд (этот способ устаревший и не рекомендуется для использования, в будущем он будем выключен)
Добавляем запись на каждый справочник в rdm_sync.version. Заполняем колонки code - код справочника в НСИ, sys_table - название таблицы в бд клиента, unique_sys_field - заполняем значением “code”, deleted_field - заполняем значением “is_deleted ”.
Добавляем запись на каждое поле справочника(которое нужно скопировать в бд клиента) в rdm_sync.field_mapping. Поле справочника, которое является первичным ключом справочника в НСИ, должно маппиться в колонку code
Пример :
```
insert into rdm_sync.version(code, sys_table, unique_sys_field, deleted_field)
select 'S019', 'rdm.grade_test', 'code', 'is_deleted';

insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'code', 'varchar', 'id';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'test_text', 'varchar', 'test_text';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'sequence', 'integer', 'sequence';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'grade_request_id', 'varchar', 'grade_request_id';
insert into rdm_sync.field_mapping(code, sys_field, sys_data_type, rdm_field) select 'S019', 'is_required', 'boolean', 'is_required';
```
### Через xml (рекомендованный способ)
В classpath (например в папку resources) подкладываем файл с наименование *rdm-mapping.xml*. В случае изменения маппинга меняем в файле соответвующий элемент refbook и увеличиваем mapping-version на 1.
Пример:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<mapping>

    <refbook code="T001" sys-table="rdm.test_rb" unique-sys-field="code" deleted-field="is_deleted" mapping-version="1">
        <field sys-field="code" sys-data-type="varchar" rdm-field="id"/>
        <field sys-field="name" sys-data-type="varchar" rdm-field="short_name"/>
        <field sys-field="doc_number" sys-data-type="integer" rdm-field="doc_num"/>
    </refbook>

    <refbook code="R001" sys-table="rdm.some_table" unique-sys-field="code" deleted-field="is_deleted" mapping-version="1">
        <field sys-field="code" sys-data-type="varchar" rdm-field="id"/>
        <field sys-field="name" sys-data-type="varchar" rdm-field="short_name"/>
    </refbook>

</mapping>
```

**Важно:** Маппинг должен соответствовать тому что есть в НСИ и в клиентском приложении. Т.е в маппинге не должно быть несуществующих полей и в НСИ и в локальной таблице.

## Из ограничений:
- справочники без первичных ключей не смогут синхронизироваться.
- строковый тип в НСИ можно мапить в "varchar", "text", "character varying", "smallint", "integer", "bigint", "serial", "bigserial", boolean(true/false), "numeric", "decimal",  "date(yyyy-MM-dd)"
- дату из НСИ можно  мапить в "date", "varchar", "text", "character varying"
- дробный в НСИ можно маппить в "numeric", "decimal", "varchar", "text", "character varying"
-логический тип в НСИ можно маппить в boolean, "varchar", "text", "character varying"




## Создание таблиц для копирования данных из НСИ

Таблицы создавать в схеме rdm.
Таблица должна содержать технические колонки :
UUID id - внутрений первичный ключ таблицы, на него можно ссылаться внутри системы.
code - любой совместимый тип с типом первичного ключа справочника в нси. В эту колонку будет копироваться значение первичного ключа справочника в нси. Указывается в колонке rdm_sync.version.unique_sys_field
is_deleted - признак удалена ли запись или нет. указывается в колонке rdm_sync.version.deleted_field
Таблица должна содержать для значений справочника, т.е те колонки в которые будут копироваться данные из полей справочника. Их кол-во и название не обязательно должны совпадать. Эти колонки участвуют в маппинге, т.е прописываются в rdm_sync.field_mapping

**Важно:** Синхронизация не создает таблиц для копирования данных из НСИ, это должно сделать клиентское приложение


## Автоматический импорт справочника по событию публикации:

Требуется наличие брокера сообщений для взамодействия клиентского приложения и системы НСИ. Это либо ActiveMQ реализующий спецификацию JMS 1.1, либо Artemis реализующий спецификацию JMS 2.0
<br/>
В клиентском приложение необходимо:
1. Необходимо задать значение свойств `rdm_sync.publish.listener.enable`, `spring.activemq.broker-url`.  
Первое включает(надо указать значение true) возможность импортировать справочник по событию (по - умолчанию выключено, значение false).  
Второе свойство -- это адрес брокера ActiveMQ. Он должен совпадать с адресом брокера, на который уходят сообщения о публикации, т.е с аналогичной настройкой для rdm-rest.  

2.Добавить зависимость maven
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>
```
или 
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-artemis</artifactId>
</dependency>
```
Можно использовать либо JMS 1.1 (ActiveMQ), либо JMS 2.0 (Artemis), т.е. если указываем  `rdm_sync.publish.listener.enable` как `true` -- добавляем зависимости либо от ActiveMQ, либо от Artemis (но не обе!).  
В случае с ActiveMQ справочник при событии публикации будет блокироваться (так как спецификация JMS 1.1 не поддерживает механизм SharedSubscription и сообщение о публикации примерно одновременно получат все узлы кластера).  
В случае с Artemis-ом блокировок не будет и можно параллельно с синхронизацией модифицировать таблицу со справочником (желательно ограничиться только добавлением записей, которых там точно никогда быть не могло, чтобы избежать конфликтов).


## Возможность экспортировать данные в НСИ
- Если в вашем приложении есть какая - то сущность, которая отражена в НСИ -- вы можете экспортировать ее.  
Сущности, которые вы синхронизируете с НСИ должны реализовывать интерфейс `Serializable`. То же самое применяется для всех полей сущности рекурсивно. Вы можете передать либо экземпляр какой - то конкретной сущности, либо `Map`. В первом случае все поля сущности (вплоть до `Object`-а) будут сложены в `Map` (нерелевантные поля будут отфильтрованы на стороне НСИ).  
В НСИ в качестве первичного ключа записи используются идентификаторы, которые вам в общем случае неизвестны, поэтому все операции `Update/Delete` выполняются по первичному ключу **справочника**, который должен быть представлен в вашей сущности.
Базовый интерфейс для данной операции отражен в `ru.inovus.ms.rdm.sync.service.change_data.RdmChangeDataClient`.  
У данного интерфейса есть две реализации, синхронная и асинхронная. Синхронная блокирует вызывающего, асинхронная положит сообщение в очередь и сразу вернет управление.  
Чтобы явно указать синхронную реализацию (хотя это делать необязательно, по - умолчанию используется именно синхронная реализация) -- необходимо задать значения свойства `rdm_sync.change_data_mode` как `sync`.  
Соответственно для асинхронной реализации указываем `async`.  
Если вы решили использовать синхронную реализацию -- убедить, что вы сконфигурировали брокера сообщений. Также в classpath-е должна быть реализация JMS спецификации (например, ActiveMQ).  
Результаты и синхронной, и асинхронной операций можно перехватить через `ru.inovus.ms.rdm.sync.service.change_data.RdmChangeDataRequestCallback`. По - умолчанию она просто логгирует в консоль.  
Стоит отметить, что в асинхронной реализации контейнер слушателя установлен как транзакционный. Это значит, что spring-jms не отправит Acknowledge брокеру сообщений в случае, если метод слушателя (помеченный как @JmsListener) кинет исключение.
Поэтому необходимо выставить разумные значения для двух параметров: кол - во попыток и задержка между ними. Однако в спецификации JMS эти параметры не указаны и настраиваются на стороне брокера.  
Например, если у вас Artemis -- то в папке `${artemis-broker}/etc` лежит файл `broker.xml`. В нем есть секция `<address-settings>`. Туда можно добавить `<address-setting>` с `match=jms.queue.${rdm_sync.change_data.queue}` (по - умолчанию `rdm_sync.change_data.queue` равна `rdmChangeData`). Внутри прописываем `<redelivery-delay>DELAY</redelivery-delay>`. В `DELAY` подставляем разумное значение (5 секунд, например) в милисекундах. И туда же прописываем `<max-delivery-attempts>ATTEMPTS</max-delivery-attempts>`.  
Аналогичные настройки можно найти у других брокеров.


## Возможность обновлять данные в локальной таблице (и со временем в НСИ)
Эта возможность является логическим продолжением предыдущей.  
Локальные таблицы хранят в себе системное поле, указывающее в каком отношении с соответствующей записью в НСИ находится локальная запись.  
Это поле может принимать 4 значения.  
1) `SYNCED` -- указывающее, что локальная запись была синхронизирована с НСИ и с тех пор не менялась (то есть при условии, что в НСИ не публиковали справочник, эта запись -- корректное отражение ее в локальной таблице).  
2) `DIRTY` -- указывающее, что локальная запись была отредактирована (либо руками, либо программно) и она уже не отражает соотвествующую запись в НСИ.
3) `PENDING` -- указывающее, что локальная запись была поставлена в очередь на экспорт ее в НСИ.
4) `ERROR` -- указывающее, что экспорт в НСИ завершился с ошибкой. Это состояние также логически является расширением состояния `DIRTY`.  
Диаграмма переходов состояний, при условии, что запись не модифицируется во время пребывания ее в состоянии `PENDING` (что не рекомендуется, иначе можно нарушить порядок доставки в НСИ), выглядит так:  
`SYNCHED`→`DIRTY`  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↙  
`PENDING`→`ERROR`  
Также надо отметить, что запись в случае использования асинхронной реализации `ru.inovus.ms.rdm.sync.service.change_data.RdmChangeDataClient` может остаться в состоянии `PENDING` на неограниченное кол-во времени.  
Если вы настроили периодическую синхронизацию с НСИ -- она со временем перейдет в `SYNCED`. Просто стоит помнить, что любое состояние, отличное от `SYNCED` не отражает реальное положение вещей в НСИ.  
Чтобы узнать состояние записи необходимо воспользоваться `ru.inovus.ms.rdm.sync.service.RdmSyncLocalRowStateService`.

## Настройка периодического обновления справочников
Для того, чтобы гарантировать, что локальные справочники со временем будут идентичны RDM-овским -- желательно для них настроить обновление по таймеру.  
Желательно сделать это через Quartz-овский шедулер в кластерном режиме (и пометить Job по обновлению справочников Quartz-овской аннотацией org.quartz.DisallowConcurrentExecution).  
Также cron-выражения нужно выбрать аккуратно, а не так, что у вас допустим 10 справочников и для каждого одно и то же выражение. Надо "размазать" эти 10 справочников по скажем часовому интервалу (то есть 6 минут на каждый).  
Обычная настройка всего этого будет такая:  
1) Автовайрим интерфейс ru.inovus.ms.rdm.sync.rest.RdmSyncRest через AutoWiringSpringBeanJobFactory (по примеру отсюда: https://stackoverflow.com/questions/6990767/inject-bean-reference-into-a-quartz-job-in-spring/15211030)
2) И в методе org.quart.Job#execute вызываем его метод ru.inovus.ms.rdm.sync.rest.RdmSyncRest#update(String refBookCode).  
То есть желательно либо создать по джобу на каждый справочник (со своим cron-ом), либо как-то самим координировать в джобе, чтобы они не запускались разом. Или скажем если у вас несколько экземпляров приложения (скажем 3), можно сделать по 3 concurrent джоба одновременно и т.д.